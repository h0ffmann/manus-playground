{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "CloudFormation template for EC2 Browser Automation instances",
  "Parameters": {
    "InstanceType": {
      "Description": "EC2 instance type",
      "Type": "String",
      "Default": "t2.medium",
      "AllowedValues": ["t2.micro", "t2.small", "t2.medium", "t2.large"],
      "ConstraintDescription": "must be a valid EC2 instance type."
    },
    "KeyName": {
      "Description": "Name of an existing EC2 KeyPair to enable SSH access to the instance",
      "Type": "AWS::EC2::KeyPair::KeyName",
      "ConstraintDescription": "must be the name of an existing EC2 KeyPair."
    },
    "VpcId": {
      "Description": "VPC ID",
      "Type": "AWS::EC2::VPC::Id",
      "ConstraintDescription": "must be the ID of an existing VPC."
    },
    "SubnetId": {
      "Description": "Subnet ID",
      "Type": "AWS::EC2::Subnet::Id",
      "ConstraintDescription": "must be the ID of an existing subnet."
    },
    "SSHLocation": {
      "Description": "The IP address range that can be used to SSH to the EC2 instances",
      "Type": "String",
      "MinLength": "9",
      "MaxLength": "18",
      "Default": "0.0.0.0/0",
      "AllowedPattern": "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})",
      "ConstraintDescription": "must be a valid IP CIDR range of the form x.x.x.x/x."
    }
  },
  "Resources": {
    "BrowserAutomationSecurityGroup": {
      "Type": "AWS::EC2::SecurityGroup",
      "Properties": {
        "GroupDescription": "Enable SSH and browser automation ports",
        "VpcId": { "Ref": "VpcId" },
        "SecurityGroupIngress": [
          {
            "IpProtocol": "tcp",
            "FromPort": "22",
            "ToPort": "22",
            "CidrIp": { "Ref": "SSHLocation" }
          },
          {
            "IpProtocol": "tcp",
            "FromPort": "3000",
            "ToPort": "3000",
            "CidrIp": "0.0.0.0/0"
          },
          {
            "IpProtocol": "tcp",
            "FromPort": "3001",
            "ToPort": "3001",
            "CidrIp": "0.0.0.0/0"
          }
        ]
      }
    },
    "BrowserAutomationInstance": {
      "Type": "AWS::EC2::Instance",
      "Properties": {
        "InstanceType": { "Ref": "InstanceType" },
        "SecurityGroupIds": [{ "Ref": "BrowserAutomationSecurityGroup" }],
        "KeyName": { "Ref": "KeyName" },
        "SubnetId": { "Ref": "SubnetId" },
        "ImageId": { "Fn::FindInMap": ["RegionMap", { "Ref": "AWS::Region" }, "AMI"] },
        "UserData": {
          "Fn::Base64": {
            "Fn::Join": [
              "",
              [
                "#!/bin/bash\n",
                "# CloudFormation User Data Script\n",
                "# This script decodes and executes the bootstrap script\n\n",
                "# Create bootstrap script\n",
                "cat > /tmp/bootstrap.sh << 'BOOTSTRAP_EOF'\n",
                "#!/bin/bash\n",
                "# EC2 Instance Bootstrap Script for Browser Automation\n",
                "# This script installs all dependencies required for running browser automation on EC2\n\n",
                "# Log setup\n",
                "exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1\n",
                "echo \"Starting EC2 instance bootstrapping process...\"\n\n",
                "# Update system packages\n",
                "apt-get update\n",
                "apt-get upgrade -y\n\n",
                "# Install system dependencies\n",
                "apt-get install -y \\\n",
                "    curl \\\n",
                "    wget \\\n",
                "    gnupg \\\n",
                "    ca-certificates \\\n",
                "    fonts-liberation \\\n",
                "    libasound2 \\\n",
                "    libatk-bridge2.0-0 \\\n",
                "    libatk1.0-0 \\\n",
                "    libc6 \\\n",
                "    libcairo2 \\\n",
                "    libcups2 \\\n",
                "    libdbus-1-3 \\\n",
                "    libexpat1 \\\n",
                "    libfontconfig1 \\\n",
                "    libgbm1 \\\n",
                "    libgcc1 \\\n",
                "    libglib2.0-0 \\\n",
                "    libgtk-3-0 \\\n",
                "    libnspr4 \\\n",
                "    libnss3 \\\n",
                "    libpango-1.0-0 \\\n",
                "    libpangocairo-1.0-0 \\\n",
                "    libstdc++6 \\\n",
                "    libx11-6 \\\n",
                "    libx11-xcb1 \\\n",
                "    libxcb1 \\\n",
                "    libxcomposite1 \\\n",
                "    libxcursor1 \\\n",
                "    libxdamage1 \\\n",
                "    libxext6 \\\n",
                "    libxfixes3 \\\n",
                "    libxi6 \\\n",
                "    libxrandr2 \\\n",
                "    libxrender1 \\\n",
                "    libxss1 \\\n",
                "    libxtst6 \\\n",
                "    lsb-release \\\n",
                "    xdg-utils \\\n",
                "    git\n\n",
                "echo \"System dependencies installed successfully\"\n\n",
                "# Install Node.js\n",
                "curl -fsSL https://deb.nodesource.com/setup_18.x | bash -\n",
                "apt-get install -y nodejs\n",
                "echo \"Node.js installed: $(node --version)\"\n",
                "echo \"NPM installed: $(npm --version)\"\n\n",
                "# Install Chrome\n",
                "wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -\n",
                "echo \"deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main\" > /etc/apt/sources.list.d/google-chrome.list\n",
                "apt-get update\n",
                "apt-get install -y google-chrome-stable\n",
                "echo \"Google Chrome installed: $(google-chrome --version)\"\n\n",
                "# Create application directory\n",
                "mkdir -p /opt/browser-service\n",
                "echo \"Created application directory at /opt/browser-service\"\n\n",
                "# Install Puppeteer and Express\n",
                "cd /opt/browser-service\n",
                "npm init -y\n",
                "npm install puppeteer express socket.io cors\n",
                "echo \"Installed Node.js dependencies\"\n\n",
                "# Create browser service script\n",
                "cat > /opt/browser-service/server.js << 'EOF'\n",
                "const express = require('express');\n",
                "const puppeteer = require('puppeteer');\n",
                "const http = require('http');\n",
                "const { Server } = require('socket.io');\n",
                "const cors = require('cors');\n\n",
                "const app = express();\n",
                "const server = http.createServer(app);\n",
                "const io = new Server(server, {\n",
                "  cors: {\n",
                "    origin: '*',\n",
                "    methods: ['GET', 'POST']\n",
                "  }\n",
                "});\n\n",
                "app.use(cors());\n",
                "app.use(express.json());\n\n",
                "let browser;\n",
                "let page;\n\n",
                "// Initialize browser\n",
                "async function initBrowser() {\n",
                "  console.log('Initializing browser...');\n",
                "  browser = await puppeteer.launch({\n",
                "    headless: true,\n",
                "    args: [\n",
                "      '--no-sandbox',\n",
                "      '--disable-setuid-sandbox',\n",
                "      '--disable-dev-shm-usage',\n",
                "      '--disable-accelerated-2d-canvas',\n",
                "      '--disable-gpu'\n",
                "    ]\n",
                "  });\n",
                "  \n",
                "  page = await browser.newPage();\n",
                "  await page.setViewport({ width: 1280, height: 800 });\n",
                "  \n",
                "  console.log('Browser initialized');\n",
                "}\n\n",
                "// API routes\n",
                "app.get('/health', (req, res) => {\n",
                "  res.json({ status: 'ok', timestamp: new Date().toISOString() });\n",
                "});\n\n",
                "// Socket.IO handlers\n",
                "io.on('connection', (socket) => {\n",
                "  console.log('Client connected');\n",
                "  \n",
                "  socket.on('navigate', async (data) => {\n",
                "    try {\n",
                "      console.log(`Navigating to: ${data.url}`);\n",
                "      if (!browser || !page) {\n",
                "        await initBrowser();\n",
                "      }\n",
                "      \n",
                "      await page.goto(data.url, { waitUntil: 'networkidle2' });\n",
                "      \n",
                "      const screenshot = await page.screenshot({ encoding: 'base64' });\n",
                "      const content = await page.content();\n",
                "      \n",
                "      // Get all clickable elements\n",
                "      const elements = await page.evaluate(() => {\n",
                "        const clickableElements = Array.from(document.querySelectorAll('a, button, input, select, [role=\"button\"]'));\n",
                "        return clickableElements.map((el, index) => {\n",
                "          const rect = el.getBoundingClientRect();\n",
                "          return {\n",
                "            id: index,\n",
                "            tag: el.tagName.toLowerCase(),\n",
                "            text: el.textContent || el.value || '',\n",
                "            x: rect.x,\n",
                "            y: rect.y,\n",
                "            width: rect.width,\n",
                "            height: rect.height\n",
                "          };\n",
                "        });\n",
                "      });\n",
                "      \n",
                "      socket.emit('navigateResult', {\n",
                "        success: true,\n",
                "        screenshot: 'data:image/png;base64,' + screenshot,\n",
                "        content,\n",
                "        url: data.url,\n",
                "        elements\n",
                "      });\n",
                "    } catch (error) {\n",
                "      console.error('Navigation error:', error);\n",
                "      socket.emit('navigateResult', {\n",
                "        success: false,\n",
                "        error: error.message\n",
                "      });\n",
                "    }\n",
                "  });\n",
                "  \n",
                "  socket.on('click', async (data) => {\n",
                "    try {\n",
                "      console.log(`Clicking element: ${data.selector || `at (${data.x}, ${data.y})`}`);\n",
                "      if (!browser || !page) {\n",
                "        throw new Error('Browser not initialized');\n",
                "      }\n",
                "      \n",
                "      if (data.selector) {\n",
                "        await page.click(data.selector);\n",
                "      } else if (data.x !== undefined && data.y !== undefined) {\n",
                "        await page.mouse.click(data.x, data.y);\n",
                "      }\n",
                "      \n",
                "      await page.waitForTimeout(1000);\n",
                "      \n",
                "      const screenshot = await page.screenshot({ encoding: 'base64' });\n",
                "      const content = await page.content();\n",
                "      \n",
                "      // Get all clickable elements\n",
                "      const elements = await page.evaluate(() => {\n",
                "        const clickableElements = Array.from(document.querySelectorAll('a, button, input, select, [role=\"button\"]'));\n",
                "        return clickableElements.map((el, index) => {\n",
                "          const rect = el.getBoundingClientRect();\n",
                "          return {\n",
                "            id: index,\n",
                "            tag: el.tagName.toLowerCase(),\n",
                "            text: el.textContent || el.value || '',\n",
                "            x: rect.x,\n",
                "            y: rect.y,\n",
                "            width: rect.width,\n",
                "            height: rect.height\n",
                "          };\n",
                "        });\n",
                "      });\n",
                "      \n",
                "      socket.emit('clickResult', {\n",
                "        success: true,\n",
                "        screenshot: 'data:image/png;base64,' + screenshot,\n",
                "        content,\n",
                "        elements\n",
                "      });\n",
                "    } catch (error) {\n",
                "      console.error('Click error:', error);\n",
                "      socket.emit('clickResult', {\n",
                "        success: false,\n",
                "        error: error.message\n",
                "      });\n",
                "    }\n",
                "  });\n",
                "  \n",
                "  socket.on('type', async (data) => {\n",
                "    try {\n",
                "      console.log(`Typing text in ${data.selector}: ${data.text}`);\n",
                "      if (!browser || !page) {\n",
                "        throw new Error('Browser not initialized');\n",
                "      }\n",
                "      \n",
                "      if (data.selector) {\n",
                "        await page.type(data.selector, data.text);\n",
                "      }\n",
                "      \n",
                "      if (data.pressEnter) {\n",
                "        await page.keyboard.press('Enter');\n",
                "      }\n",
                "      \n",
                "      await page.waitForTimeout(500);\n",
                "      \n",
                "      const screenshot = await page.screenshot({ encoding: 'base64' });\n",
                "      const content = await page.content();\n",
                "      \n",
                "      socket.emit('typeResult', {\n",
                "        success: true,\n",
                "        screenshot: 'data:image/png;base64,' + screenshot,\n",
                "        content\n",
                "      });\n",
                "    } catch (error) {\n",
                "      console.error('Type error:', error);\n",
                "      socket.emit('typeResult', {\n",
                "        success: false,\n",
                "        error: error.message\n",
                "      });\n",
                "    }\n",
                "  });\n",
                "  \n",
                "  socket.on('screenshot', async (data) => {\n",
                "    try {\n",
                "      console.log('Taking screenshot');\n",
                "      if (!browser || !page) {\n",
                "        throw new Error('Browser not initialized');\n",
                "      }\n",
                "      \n",
                "      const screenshot = await page.screenshot({ encoding: 'base64' });\n",
                "      \n",
                "      socket.emit('screenshotResult', {\n",
                "        success: true,\n",
                "        screenshot: 'data:image/png;base64,' + screenshot\n",
                "      });\n",
                "    } catch (error) {\n",
                "      console.error('Screenshot error:', error);\n",
                "      socket.emit('screenshotResult', {\n",
                "        success: false,\n",
                "        error: error.message\n",
                "      });\n",
                "    }\n",
                "  });\n",
                "  \n",
                "  socket.on('execute', async (data) => {\n",
                "    try {\n",
                "      console.log('Executing JavaScript');\n",
                "      if (!browser || !page) {\n",
                "        throw new Error('Browser not initialized');\n",
                "      }\n",
                "      \n",
                "      const result = await page.evaluate(data.script);\n",
                "      \n",
                "      socket.emit('executeResult', {\n",
                "        success: true,\n",
                "        result\n",
                "      });\n",
                "    } catch (error) {\n",
                "      console.error('Execute error:', error);\n",
                "      socket.emit('executeResult', {\n",
                "        success: false,\n",
                "        error: error.message\n",
                "      });\n",
                "    }\n",
                "  });\n",
                "  \n",
                "  socket.on('scroll', async (data) => {\n",
                "    try {\n",
                "      console.log(`Scrolling ${data.direction} by ${data.amount}`);\n",
                "      if (!browser || !page) {\n",
                "        throw new Error('Browser not initialized');\n",
                "      }\n",
                "      \n",
                "      const scrollAmount = data.direction === 'up' ? -data.amount : data.amount;\n",
                "      \n",
                "      await page.evaluate((amount) => {\n",
                "        window.scrollBy(0, amount);\n",
                "      }, scrollAmount);\n",
                "      \n",
                "      await page.waitForTimeout(500);\n",
                "      \n",
                "      const screenshot = await page.screenshot({ encoding: 'base64' });\n",
                "      const content = await page.content();\n",
                "      \n",
                "      socket.emit('scrollResult', {\n",
                "        success: true,\n",
                "        screenshot: 'data:image/png;base64,' + screenshot,\n",
                "        content\n",
                "      });\n",
                "    } catch (error) {\n",
                "      console.error('Scroll error:', error);\n",
                "      socket.emit('scrollResult', {\n",
                "        success: false,\n",
                "        error: error.message\n",
                "      });\n",
                "    }\n",
                "  });\n",
                "  \n",
                "  socket.on('disconnect', () => {\n",
                "    console.log('Client disconnected');\n",
                "  });\n",
                "});\n\n",
                "// Initialize and start server\n",
                "async function start() {\n",
                "  try {\n",
                "    await initBrowser();\n",
                "    \n",
                "    const PORT = process.env.PORT || 3000;\n",
                "    server.listen(PORT, '0.0.0.0', () => {\n",
                "      console.log(`Browser service running on port ${PORT}`);\n",
                "    });\n",
                "  } catch (error) {\n",
                "    console.error('Failed to start browser service:', error);\n",
                "    process.exit(1);\n",
                "  }\n",
                "}\n\n",
                "start();\n\n",
                "// Handle shutdown\n",
                "process.on('SIGINT', async () => {\n",
                "  console.log('Shutting down...');\n",
                "  if (browser) {\n",
                "    await browser.close();\n",
                "  }\n",
                "  process.exit();\n",
                "});\n",
                "EOF\n\n",
                "echo \"Created browser service script\"\n\n",
                "# Create systemd service\n",
                "cat > /etc/systemd/system/browser-service.service << EOF\n",
                "[Unit]\n",
                "Description=Browser Automation Service\n",
                "After=network.target\n\n",
                "[Service]\n",
                "Type=simple\n",
                "User=root\n",
                "WorkingDirectory=/opt/browser-service\n",
                "ExecStart=/usr/bin/node server.js\n",
                "Restart=always\n",
                "RestartSec=10\n",
                "StandardOutput=syslog\n",
                "StandardError=syslog\n",
                "SyslogIdentifier=browser-service\n",
                "Environment=NODE_ENV=production\n\n",
                "[Install]\n",
                "WantedBy=multi-user.target\n",
                "EOF\n\n",
                "echo \"Created systemd service file\"\n\n",
                "# Enable and start service\n",
                "systemctl daemon-reload\n",
                "systemctl enable browser-service\n",
                "systemctl start browser-service\n",
                "echo \"Browser service enabled and started\"\n\n",
                "# Register with backend (if applicable)\n",
                "INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)\n",
                "PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)\n",
                "PUBLIC_DNS=$(curl -s http://169.254.169.254/latest/meta-data/public-hostname)\n\n",
                "echo \"Instance metadata:\"\n",
                "echo \"Instance ID: $INSTANCE_ID\"\n",
                "echo \"Public IP: $PUBLIC_IP\"\n",
                "echo \"Public DNS: $PUBLIC_DNS\"\n\n",
                "# Add security measures\n",
                "# Set up firewall to only allow necessary ports\n",
                "apt-get install -y ufw\n",
                "ufw default deny incoming\n",
                "ufw default allow outgoing\n",
                "ufw allow ssh\n",
                "ufw allow 3000/tcp\n",
                "ufw --force enable\n",
                "echo \"Firewall configured and enabled\"\n\n",
                "# Create a status endpoint for health checks\n",
                "cat > /opt/browser-service/status.js << EOF\n",
                "const http = require('http');\n",
                "const os = require('os');\n\n",
                "const server = http.createServer((req, res) => {\n",
                "  if (req.url === '/status') {\n",
                "    const status = {\n",
                "      timestamp: new Date().toISOString(),\n",
                "      uptime: os.uptime(),\n",
                "      hostname: os.hostname(),\n",
                "      instance_id: '$INSTANCE_ID',\n",
                "      public_ip: '$PUBLIC_IP',\n",
                "      public_dns: '$PUBLIC_DNS',\n",
                "      memory: {\n",
                "        total: os.totalmem(),\n",
                "        free: os.freemem()\n",
                "      },\n",
                "      cpu_load: os.loadavg(),\n",
                "      browser_service: 'running'\n",
                "    };\n",
                "    \n",
                "    res.writeHead(200, { 'Content-Type': 'application/json' });\n",
                "    res.end(JSON.stringify(status, null, 2));\n",
                "  } else {\n",
                "    res.writeHead(404);\n",
                "    res.end();\n",
                "  }\n",
                "});\n\n",
                "server.listen(3001, '0.0.0.0', () => {\n",
                "  console.log('Status server running on port 3001');\n",
                "});\n",
                "EOF\n\n",
                "# Create systemd service for status endpoint\n",
                "cat > /etc/systemd/system/status-service.service << EOF\n",
                "[Unit]\n",
                "Description=Browser Automation Status Service\n",
                "After=network.target\n\n",
                "[Service]\n",
                "Type=simple\n",
                "User=root\n",
                "WorkingDirectory=/opt/browser-service\n",
                "ExecStart=/usr/bin/node status.js\n",
                "Restart=always\n",
                "RestartSec=10\n",
                "StandardOutput=syslog\n",
                "StandardError=syslog\n",
                "SyslogIdentifier=status-service\n",
                "Environment=NODE_ENV=production\n\n",
                "[Install]\n",
                "WantedBy=multi-user.target\n",
                "EOF\n\n",
                "# Enable and start status service\n",
                "systemctl daemon-reload\n",
                "systemctl enable status-service\n",
                "systemctl start status-service\n",
                "echo \"Status service enabled and started\"\n\n",
                "# Allow status service port in firewall\n",
                "ufw allow 3001/tcp\n",
                "echo \"Opened firewall for status service\"\n\n",
                "echo \"EC2 instance bootstrapping completed successfully!\"\n",
                "BOOTSTRAP_EOF\n\n",
                "# Execute bootstrap script\n",
                "chmod +x /tmp/bootstrap.sh\n",
                "/tmp/bootstrap.sh\n\n",
                "# Signal CloudFormation that the instance is ready\n",
                "/opt/aws/bin/cfn-signal -e $? --stack ", { "Ref": "AWS::StackName" }, " --resource BrowserAutomationInstance --region ", { "Ref": "AWS::Region" }, "\n"
              ]
            ]
          }
        },
        "Tags": [
          {
            "Key": "Name",
            "Value": "BrowserAutomation"
          },
          {
            "Key": "Service",
            "Value": "Manus-EC2-Browser"
          }
        ],
        "CreationPolicy": {
          "ResourceSignal": {
            "Timeout": "PT15M"
          }
        }
      }
    }
  },
  "Mappings": {
    "RegionMap": {
      "us-east-1": { "AMI": "ami-0c55b159cbfafe1f0" },
      "us-east-2": { "AMI": "ami-0568773882d492fc8" },
      "us-west-1": { "AMI": "ami-0b2ca94b5b49e0132" },
      "us-west-2": { "AMI": "ami-0e34e7b9ca0ace12d" },
      "eu-west-1": { "AMI": "ami-0ff8a91507f77f867" },
      "eu-central-1": { "AMI": "ami-0cc0a36f626a4fdf5" },
      "ap-northeast-1": { "AMI": "ami-0c3fd0f5d33134a76" },
      "ap-southeast-1": { "AMI": "ami-0f7719e8b7c4d6479" }
    }
  },
  "Outputs": {
    "InstanceId": {
      "Description": "Instance ID of the EC2 instance",
      "Value": { "Ref": "BrowserAutomationInstance" }
    },
    "PublicDNS": {
      "Description": "Public DNS of the EC2 instance",
      "Value": { "Fn::GetAtt": ["BrowserAutomationInstance", "PublicDnsName"] }
    },
    "PublicIP": {
      "Description": "Public IP of the EC2 instance",
      "Value": { "Fn::GetAtt": ["BrowserAutomationInstance", "PublicIp"] }
    },
    "BrowserServiceURL": {
      "Description": "URL for the browser automation service",
      "Value": { "Fn::Join": ["", ["http://", { "Fn::GetAtt": ["BrowserAutomationInstance", "PublicDnsName"] }, ":3000"]] }
    },
    "StatusServiceURL": {
      "Description": "URL for the status service",
      "Value": { "Fn::Join": ["", ["http://", { "Fn::GetAtt": ["BrowserAutomationInstance", "PublicDnsName"] }, ":3001/status"]] }
    }
  }
}
